---
title: handling-r-errors
author: ~
date: '2018-09-23'
slug: handling-r-errors
categories: []
tags: []
subtitle: ''
---

```{r setup, include=FALSE }
knitr::opts_chunk$set(echo = TRUE, warning = F, message = F, comment = "", error = TRUE)
```

Every day we deal with `errors`, `warnings` and `messages` while writing, debugging or reviewing code. The three types belong to `conditions` in `R`. You might hope to see as few of them as possible, but actually they are so helpful when they describe the problem concisely and refer to its source. So if you write functions or code for yourself or others, it is a good practice to spend more time in writing descriptive conditions. I, persoanlly, was not following this advice all the time, but as I am getting into this habit, I learnt more about the condition handling system in `R` and also about the improvements `rlang` provides.

In this post I will highlight the basics of condition handling. Then we'll see the benefits of custom conditions provided by `rlang`.  

## Conditions in R

in `R` `conditions` are regular objects and they mainly include:

- `error`: signaled by `stop()`
- `warning`: generated by `warning()`
- `message`: generated by `message()`


Let's see an example with a simple function; `my_sqrt()` that raises an error when a negative number is passed to it.

```{r}
## define my_sqrt() that only takes positive numbers
my_sqrt <- function(x){
  if((x) < 0) {
    stop("x must be positive")
  } else {
    sqrt(x)
  }
}
```

Now if you pass -1 to `my_sqrt()`, it will exit and show you the message which you specified inside `stop()`.

```{r}
## pass -ve number to my_sqrt()
my_sqrt(-1)
```

**But how can we handle `conditions`?**

## Condition handling

`tryCatch` is one of the ways to inspect condition objects and control what happens when a condition is signalled.

For instance, we can define an error handler to decide what happens when `my_sqrt()` fails. So here  `function(cnd) cnd` says *"catch the error object and return it"*. If you inspect the returned value `sqrt_cnd` you can see a list with:

- `message`: the error message you defined in `my_sqrt`.
- `call`: the function call that raised this error.


```{r}
## define an error handler to return the error object when an error is thrown
sqrt_cnd <- tryCatch(error = function(cnd) cnd, my_sqrt(-1))

str(sqrt_cnd)
```

Since the error handler is a normal function, you can decide what to return other than the `message` and `call`. For instance, instead of catching the error and throwing it, you can return a value; here `0`. 

```{r}
## define an error handler to return 0 when an error is thrown
sqrt_cnd <- tryCatch(error = function(x) 0, my_sqrt(-1))

## inspect sqrt_cnd
str(sqrt_cnd)
```

**But What if we had a chain of functions, where a function calls another one, and errors can be raised by either of them?**


## Conditions with a chain of functions


In practice, we usually write functions that call other functions and we might get lost if we don't have an easy way to find the source of the error or decide what to do when it is thrown.

To see this case, let's define two functions for demo purposes:

- `get_val()`: which return the random value if positive and raises an error if negative. *(this is to simulate random inputs or fetching data from users, database, etc.)* 

```{r}
## define get_val() to simulate random input values
get_val <- function(){
  val <- runif(1, -10, 10)
  if (val < 1){
    stop("Can't get val")
  } else {
    val
  }
}
```

- `double_value()`: which calls `get_val()` and multiplies the returned value by 2.

```{r}
## Note that `calc_val()` it is not a very practical example,
## because the function doesn't do a single task related to its name, 
## but I am just using it for demo purposes
calc_val <- function(){
  x <- get_val()
  x*2
}
```


```{r get_val with -ve input , echo = FALSE}
## define get_val() to simulate random input values
get_val <- function(){
  val <- -1.3556
  if (val < 1){
    stop("Can't get val")
  } else {
    val
  }
}
```

In case `val` is negative in `get_val()`, an error will be thrown as follows:

```{r}
## in case val negative 
get_val()
```

Similarly, when we call `calc_val()`, the error will jump and and we will see an error message.

```{r}
## in case val negative 
calc_val()
```

In both cases, we have the same error message and we have no info about the value of `val` that caused the error.

**So is there a way to see more info about the error, like the exact value of `val`?, or could we write more detailed messages?**


## conditions with `rlang` functions

In principle, it is possible to create custom condition objects to pass more meta-data about the error. But in `base R`, it is kind of confusing compared to what `rlang` provides. I had to look up the `base R` way and check some examples every time I wanted to hanldle such cases!

So `rlang` provides functions that correspond to `base R` ones as follows: 

| rlang    | base R    |
|----------|-----------|
| abort()  | stop()    |
| warn()   | warning() |
| inform() | message() |

`rlang` functions are designed to deal with condition objects and create custom ones easily, unlike `base R` functions that are focused on messages.

### `abort()` versus `stop()`

To clarify the difference, let's modify `get_val()` and use `abort()` instead of `stop()`. Here you can see three arguments passed to `abort()`:

- `message`: the error message which is similar to the one passed to `stop()` in the previous example.
- `.subclass`: a subclass of the condition to differentiate errors.
- `val`: the particular value that caused the error.

You can pass more values to `abort()`, and it will return a custom error object with a list of all these values.

```{r}
## define get_val() to simulate random input values
get_val <- function(){
  val <- runif(1, -10, 10)
  if (val < 1){
    rlang::abort(message = "Can't get val", 
                 .subclass ="get_val_error", 
                 val = val)
  } else {
    val
  }
}
```


```{r rlang: get_val with -ve input  , echo = FALSE}
## define get_val() to simulate random input values
get_val <- function(){
  val <- -2.8569
  if (val < 1){
    rlang::abort("Can't get val", "get_val_error", val = val)
  } else {
    val
  }
}
```

To inspect the custom error object returned by `get_val()`, you can use `tryCatch()` and assign the value to `custom_cnd`. 

```{r}
## define an error handler to return the custom error object 
custom_cnd <- tryCatch(error = function(cnd) cnd, get_val())
```
Notice that:

- the error object has the main class in addition to the defined subclass `get_val_error`.
- the value `val` which caused the error is available and you can access it using `custom_cnd$val`.

```{r}
## inspect custom_cnd
str(custom_cnd, max.level = 1)
```


**So now we have more meta-data about the error and specific subclasses. How can we use this with chained functions?**

### Condition handling with subclasses

Let's say, we want to get a more precise message when we call `calc_val()` that calls `get_val()`. For instance, a message like:

***"Can't calculate value because `get_val()` raised an error as `val` was negative (-1.5648)"***


We can define an error handler `get_val_handler()` to access the values returned in the custom error object thrown by `get_val()` then return a message based on these values. 

What `get_val_handler()` basically does is to:

- define a basic error message *"Can't calculate value"*, that will be shown anyways.
- check the class of the error object returned by `get_val()`. If the class belongs to a specific subclass `get_val_error`, it modifies the message and includes the value of `val`.
- return an error object with the final message and a subclass `calc_val_error`.
    


```{r}
## define an error handler to modify the message
get_val_handler <- function(cnd) {
  msg <- "Can't calculate value"
  
  if (inherits(cnd, "get_val_error")) {
    msg <- paste0(msg, " as `val` passed to `get_val()` equals (", cnd$val,")")
  }
  
  rlang::abort(msg, "calc_val_error")
}
```

So now if you use `get_val_handler` with `get_val()` inside `calc_val()`, you basicaly say:

***"If you catch an error from `get_val()`, get the value of `val` that caused the error and add it to the error message that will be returned by `calc_val()`"***


```{r}
## use get_val_handler() with calc_val()
calc_val <- function(){
  x <- tryCatch(error = get_val_handler, get_val())
  x*2
}
```

And here you can see an example of the modifed error message including the value of `val` that caused the error, which you couldn't have access to earlier with the default `stop()` function.

```{r}
calc_val()
```


If you want to inspect the error object returned by `calc_val()`, you can see the details including the new subclass `calc_val_error`, to which this error object belongs.

```{r}
## 
modified_cnd <- tryCatch(error = function(cnd) cnd, calc_val())

## inspect modified_cnd
str(modified_cnd, max.level = 1)
```







