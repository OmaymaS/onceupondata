---
title:  'Handling R errors the rlang way' 
subtitle: 'Custom conditions, subclasses and more!'
date: '2018-09-28'
slug: handling-r-errors
tags: [R, rlang, tidyverse]
output: html_document
---



<p>Every day we deal with <code>errors</code>, <code>warnings</code> and <code>messages</code> while writing, debugging or reviewing code. The three types belong to <code>conditions</code> in <code>R</code>. You might hope to see as few of them as possible, but actually they are so helpful when they describe the problem concisely and refer to its source. So if you write functions or code for yourself or others, it is a good practice to spend more time in writing descriptive conditions. I, personally, was not following this advice all the time, but as I am getting into this habit, I learnt more about the condition handling system in <code>R</code> and also about the improvements <code>rlang</code> provides.</p>
<p>In this post I will highlight the basics of condition handling. Then we‚Äôll see the benefits of custom conditions provided by <code>rlang</code>. By the end, we will be able to understand how to generate custom conditions and throw errors with more details as shown in the following example.</p>
<div class="figure">
<img src="/post/2018-09-23-handling-r-errors/my_sqrt_image2.png" />

</div>
<div id="conditions-in-base-r" class="section level2">
<h2>Conditions in base R</h2>
<p>in <code>R</code> <code>conditions</code> are regular objects and they mainly include:</p>
<ul>
<li><code>error</code>: signaled by <code>stop()</code></li>
<li><code>warning</code>: generated by <code>warning()</code></li>
<li><code>message</code>: generated by <code>message()</code></li>
</ul>
<p>Let‚Äôs see an example with a simple function; <code>my_sqrt()</code> that raises an error when a negative number is passed to it.</p>
<pre class="r"><code>## define my_sqrt() that only takes positive numbers
my_sqrt &lt;- function(x){
  if((x) &lt; 0) {
    stop(&quot;x must be positive&quot;)
  } else {
    sqrt(x)
  }
}</code></pre>
<p>Now if you pass -1 to <code>my_sqrt()</code>, it will exit and show you the message which you specified inside <code>stop()</code>.</p>
<pre class="r"><code>## pass -ve number to my_sqrt()
my_sqrt(-1)</code></pre>
<pre><code>Error in my_sqrt(-1): x must be positive</code></pre>
<p><strong>But how can we handle <code>conditions</code> and decide what to do when they are generated?</strong></p>
</div>
<div id="condition-handling" class="section level2">
<h2>Condition handling</h2>
<p><code>tryCatch</code> is one of the ways to inspect condition objects and control what happens when a condition is signaled. For instance, we can define an error handler to decide what happens when <code>my_sqrt()</code> fails. Here, <code>function(cnd) cnd</code>, the error handler passed to the <code>error</code> argument inside <code>tryCatch()</code> says <strong><em>‚Äúcatch the error object and return it‚Äù</em></strong>.</p>
<p>If you inspect the returned value <code>sqrt_cnd</code> you can see a list with:</p>
<ul>
<li><code>message</code>: the error message you defined in <code>my_sqrt</code>.</li>
<li><code>call</code>: the function call that raised this error.</li>
</ul>
<pre class="r"><code>## define an error handler to return the error object when an error is thrown
sqrt_cnd &lt;- tryCatch(error = function(cnd) cnd, my_sqrt(-1))

str(sqrt_cnd)</code></pre>
<pre><code>List of 2
 $ message: chr &quot;x must be positive&quot;
 $ call   : language my_sqrt(-1)
 - attr(*, &quot;class&quot;)= chr [1:3] &quot;simpleError&quot; &quot;error&quot; &quot;condition&quot;</code></pre>
<p>Since the error handler is a normal function, you can decide what to return other than the <code>message</code> and <code>call</code>. For instance, instead of catching the error and throwing it, you can return a value; here <code>0</code>.</p>
<pre class="r"><code>## define an error handler to return 0 when an error is thrown
sqrt_cnd &lt;- tryCatch(error = function(x) 0, my_sqrt(-1))

str(sqrt_cnd)</code></pre>
<pre><code> num 0</code></pre>
<p><strong>But What if we had a chain of functions, where a function calls another one?</strong></p>
</div>
<div id="conditions-with-a-chain-of-functions" class="section level2">
<h2>Conditions with a chain of functions</h2>
<p>In practice, we usually write functions that call other functions and we might get lost if we don‚Äôt have an easy way to find the source of the error or decide what to do when it is thrown.</p>
<p>To see this case, let‚Äôs define two functions for demo purposes:</p>
<ul>
<li><code>get_val()</code>: which return the random value if positive and raises an error if negative. <em>(this is to simulate random inputs or fetching data from users, database, etc.)</em></li>
</ul>
<pre class="r"><code>## define get_val() to simulate random input values
get_val &lt;- function(){
  val &lt;- runif(1, -10, 10)
  if (val &lt; 1){
    stop(&quot;Can&#39;t get val&quot;)
  } else {
    val
  }
}</code></pre>
<ul>
<li><code>double_value()</code>: which calls <code>get_val()</code> and multiplies the returned value by 2.</li>
</ul>
<pre class="r"><code>## Note that `mult_val()` it is not a very practical example,
## because the function doesn&#39;t do a single task related to its name, 
## but I am just using it for demo purposes
mult_val &lt;- function(mult_by = 2){
  x &lt;- get_val()
  x*mult_by
}</code></pre>
<p>In case <code>val</code> is negative in <code>get_val()</code>, an error will be thrown as follows:</p>
<pre class="r"><code>## in case val negative 
get_val()</code></pre>
<pre><code>Error in get_val(): Can&#39;t get val</code></pre>
<p>Similarly, when we call <code>mult_val()</code>, the error will jump and and we will see an error message.</p>
<pre class="r"><code>## in case val negative 
mult_val()</code></pre>
<pre><code>Error in get_val(): Can&#39;t get val</code></pre>
<p>In both cases, we have the same error message and we have no info about the value of <code>val</code> that caused the error.</p>
<p><strong>So is there a way to see more info about the error, like the exact value of <code>val</code>?, or could we write more detailed messages?</strong></p>
</div>
<div id="conditions-in-rlang" class="section level2">
<h2>Conditions in <code>rlang</code></h2>
<p>In principle, it is possible to create custom condition objects to pass more meta-data about the error. But in <code>base R</code>, it is kind of confusing compared to what <code>rlang</code> provides. I had to look up the <code>base R</code> way and check some examples every time I wanted to handle such cases!</p>
<p>So <code>rlang</code> provides functions that correspond to <code>base R</code> ones as follows:</p>
<table>
<thead>
<tr class="header">
<th>rlang</th>
<th>base R</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>abort()</td>
<td>stop()</td>
</tr>
<tr class="even">
<td>warn()</td>
<td>warning()</td>
</tr>
<tr class="odd">
<td>inform()</td>
<td>message()</td>
</tr>
</tbody>
</table>
<p><code>rlang</code> functions are designed to deal with condition objects and create custom ones easily, unlike <code>base R</code> functions that are focused on messages.</p>
<div id="custom-conditions" class="section level3">
<h3>Custom conditions</h3>
<div id="abort-versus-stop" class="section level4">
<h4><code>abort()</code> versus <code>stop()</code></h4>
<p>To clarify the difference, let‚Äôs modify <code>get_val()</code> and use <code>abort()</code> instead of <code>stop()</code>. Here you can see three arguments passed to <code>abort()</code>:</p>
<ul>
<li><code>message</code>: the error message which is similar to the one passed to <code>stop()</code> in the previous example.</li>
<li><code>.subclass</code>: a subclass of the condition to differentiate errors.</li>
<li><code>val</code>: the particular value that caused the error.</li>
</ul>
<p>You can pass more values to <code>abort()</code>, and it will return a custom error object with a list of all these values.</p>
<pre class="r"><code>## define get_val() to simulate random input values
get_val &lt;- function(){
  val &lt;- runif(1, -10, 10)
  if (val &lt; 1){
    rlang::abort(message = &quot;Can&#39;t get val&quot;, 
                 .subclass =&quot;get_val_error&quot;, 
                 val = val)
  } else {
    val
  }
}</code></pre>
<p>To inspect the custom error object returned by <code>get_val()</code>, you can use <code>tryCatch()</code> and assign the value to <code>custom_cnd</code>.</p>
<pre class="r"><code>## define an error handler to return the custom error object 
custom_cnd &lt;- tryCatch(error = function(cnd) cnd, get_val())</code></pre>
<p>Notice that:</p>
<ul>
<li>the error object has the main classes in addition to the defined subclass <code>get_val_error</code>.</li>
<li>the value <code>val</code> which caused the error is available and you can access it using <code>custom_cnd$val</code>.</li>
</ul>
<pre class="r"><code>## inspect custom_cnd
str(custom_cnd, max.level = 1)</code></pre>
<pre><code>List of 5
 $ message: chr &quot;Can&#39;t get val&quot;
 $ call   : NULL
 $ trace  :List of 3
  ..- attr(*, &quot;class&quot;)= chr &quot;rlang_trace&quot;
 $ parent : NULL
 $ val    : num -2.86
 - attr(*, &quot;class&quot;)= chr [1:4] &quot;get_val_error&quot; &quot;rlang_error&quot; &quot;error&quot; &quot;condition&quot;</code></pre>
<p>So here‚Äôs a quick comparison between the error object returned by <code>rlang::abort()</code> in this example and the one returned by <code>stop()</code> in the previous section.</p>
<div class="figure">
<img src="/post/2018-09-23-handling-r-errors/get_val_image.png" />

</div>
<p><strong>So now we have more meta-data about the error and a specific subclasse. How can we use this with chained functions?</strong></p>
</div>
<div id="error-messages-catch-modify-rethrow" class="section level4">
<h4>Error messages (Catch, modify, rethrow)</h4>
<p>Let‚Äôs say, we want to get a more precise message when we call <code>mult_val()</code> that calls <code>get_val()</code>. For instance, a message like:</p>
<p><strong><em>‚ÄúCan‚Äôt calculate value because <code>get_val()</code> raised an error as <code>val</code> was negative (-1.5648)‚Äù</em></strong></p>
<p>We can define an error handler <code>get_val_handler()</code> to access the values returned in the custom error object thrown by <code>get_val()</code> then return a message based on these values.</p>
<p>What <code>get_val_handler()</code> basically does is to:</p>
<ul>
<li>define a basic error message <em>‚ÄúCan‚Äôt calculate value‚Äù</em>, that will be shown anyways.</li>
<li>check the class of the error object returned by <code>get_val()</code>. If the class belongs to a specific subclass <code>get_val_error</code>, the message gets modified to include the value of <code>val</code>.</li>
<li>return an error object with the final message and a subclass <code>mult_val_error</code>.</li>
</ul>
<pre class="r"><code>## define an error handler to modify the message
get_val_handler &lt;- function(cnd) {
  msg &lt;- &quot;Can&#39;t calculate value&quot;
  
  if (inherits(cnd, &quot;get_val_error&quot;)) {
    msg &lt;- paste0(msg, &quot; as `val` passed to `get_val()` equals (&quot;, cnd$val,&quot;)&quot;)
  }
  
  rlang::abort(msg, &quot;mult_val_error&quot;)
}</code></pre>
<p>So now if you use <code>get_val_handler</code> with <code>get_val()</code> inside <code>mult_val()</code>, you basically say:</p>
<p><strong><em>‚ÄúIf you catch an error from <code>get_val()</code>, get the value of <code>val</code> that caused the error and add it to the error message that will be returned by <code>mult_val()</code>‚Äù</em></strong></p>
<pre class="r"><code>## use get_val_handler() with mult_val()
mult_val &lt;- function(mult_by = 2){
  x &lt;- tryCatch(error = get_val_handler, get_val())
  x*mult_by
}</code></pre>
<p>And here you can see an example of the modified error message including the value of <code>val</code> that caused the error, which you couldn‚Äôt have access to earlier with the default <code>stop()</code> function.</p>
<pre class="r"><code>mult_val()</code></pre>
<pre><code>Error: Can&#39;t calculate value as `val` passed to `get_val()` equals (-2.8569)
[90mCall `rlang::last_error()` to see a backtrace[39m</code></pre>
<p>If you want to inspect the error object returned by <code>mult_val()</code>, you can see the details including the new subclass <code>mult_val_error</code>, to which this error object belongs.</p>
<pre class="r"><code>## define an error handler to return the error object
modified_cnd &lt;- tryCatch(error = function(cnd) cnd, mult_val())

str(modified_cnd, max.level = 1)</code></pre>
<pre><code>List of 4
 $ message: chr &quot;Can&#39;t calculate value as `val` passed to `get_val()` equals (-2.8569)&quot;
 $ call   : NULL
 $ trace  :List of 3
  ..- attr(*, &quot;class&quot;)= chr &quot;rlang_trace&quot;
 $ parent : NULL
 - attr(*, &quot;class&quot;)= chr [1:4] &quot;mult_val_error&quot; &quot;rlang_error&quot; &quot;error&quot; &quot;condition&quot;</code></pre>
</div>
</div>
</div>
<div id="conclusion" class="section level2">
<h2>Conclusion</h2>
<p>Conditions can be our friends and guides through debugging and code review processes. How useful they are depends on how clear and concise the info they give. <code>rlang</code> provides an easy way to deal with custom conditions. It allows us to pass meta-data about the conditions, which helps in better reporting and handling. The previous examples showed the differences between <code>rlang</code> and <code>base r</code> conditions. They also demonstrated how to deal with custom conditions. Most importantly, we saw how to catch, modify and rethrow an error in chained functions. So what remains is to make use of this flexibility to handle conditions and write more informative messages.</p>
</div>
<div id="extra-resources" class="section level2">
<h2>Extra Resources</h2>
<ul>
<li><a href="http://style.tidyverse.org/error-messages.html">The tidyverse style guide: Error messages</a>, by <a href="http://github.com/hadley">Hadley Wickham</a></li>
<li><a href="http://adv-r.had.co.nz/Exceptions-Debugging.html">Advanced R - Exceptions and debugging</a>, by <a href="http://github.com/hadley">Hadley Wickham</a></li>
<li><a href="https://www.dropbox.com/s/fi5fswytwatw1kk/condition-erum.pdf">Reducing bewilderment by improving errors</a>, by <a href="https://github.com/lionel-">Lionel Henry</a></li>
</ul>
<p><strong>Notes</strong></p>
<ul>
<li><p>The version of <code>rlang</code> used here is <code>rlang_0.2.2.9001</code>. I am not sure if everything works in the same way in earlier versions.</p></li>
<li><p>The functions used in the examples are not perfect since they are not pure, they don‚Äôt perform a single clear task and their names do not reflect their purpose. However, they were just used for demo purposes.</p></li>
</ul>
</div>
